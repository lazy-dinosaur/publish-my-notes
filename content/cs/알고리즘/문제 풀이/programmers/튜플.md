---
id: 튜플
aliases: []
tags: []
date: "2024-05-08"
description: ""
draft: false
title: 튜플
---

#programmers #coding-test 

## 문제 설명

셀수 있는 수량의 순서있는 열거 또는 어떤 순서를 따르는요소들의 모음을 튜플(tuple) 이라고 힙니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple) 이라고 하며, 다음과 같이 표현할 수 있습니다.
- (a1,a2,a3,...an)
튜플은 다음과 같은 성질을 가지고 있습니다.
1. 중복된 원소가 있을 수 있습니다. ex:(2,3,1,2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex:(1,2,3)!=(1,3,2)
3. 튜플의 원소 개수는 유한합니다.
원소의 개수가 n개이고, *중복되는 원소가 없는* 튜플 `(a1,a2,a3,...,an)` 이 주어질 때 (단, a1,a2,...,an은 자연수), 이는 다음과 같이 집합 기호 '{' , '}' 를 이용해 표현할 수 있습니다.

- {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는

- {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}

와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

- {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
- {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
- {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}

는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한 사항
- s의 길이는 5 이상 1,000,000 이하입니다.
- s는 숫자와 '{' , '}' , ',' 로만  이루어져 있습니다.
- 숫자가 0으로 시작하는 경우는 없습니다.
- s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
- s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
- return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

### 입출력 예
| s                                 | result       |
| --------------------------------- | ------------ |
| `"{{2},{2,1},{2,1,3},{2,1,3,4}}"` | [2, 1, 3, 4] |
| `"{{1,2,3},{2,1},{1,2,4,3},{2}}"` | [2, 1, 3, 4] |
| `"{{20,111},{111}}"`              | [111, 20]    |
| `"{{123}}"`                       | [123]        |
| `"{{4,2,3},{3},{2,3,4,1},{2,3}}"` | [3, 2, 4, 1] |
## 풀이

### 첫번째 접근

우선 문자열을 통해서 인풋이 주어지기 때문에 문자열에서 숫자에 해당하는 것만 걸러내기로 하였다.
이후 리스트가 정렬되는 순서를 보면 가장 많이 포함되어 있는 숫자가 처음 가장 적게 포함되는 숫자가 마지막으로 배치되는것을 확인하였고 이에 따라 딕셔너리를 활용하여 키값과 벨류에 어떤 숫자가 몇개만큼 나왔는지 체크하여 진행하기로 했다.

이후 [[힙큐(heapq)]] 를 이용하여 빈도가 많은 수부터 차례대로 뽑아내어 

```python
import heapq

def solution(s):
	answer=[]
	# 불필요한 문자 지우고 숫자만 존재하는 리스트 만들기
	s=s.replace(",","").replace("{","").replace("}","").split(" ")

	counts={}
	priority_list=[]

	for i in s: # 각각의 숫자가 몇개 존재하는지 카운팅
		if int(i) not in counts:
			counts[int(i)]=1
		else:
			counts[int(i)]+=1
			
	for i in counts: # 문자열에 많이 나온 빈도값을 가지고 우선순위를 부여하여 푸시
		heapq.heappush(priority_list,(-counts[i],i))
		
	while priority_list:
		count,num =heapq.heappop(priority_list)
		answer.append(num)
		
	return answer		
	
```

